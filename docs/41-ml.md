# 41 机器学习集成

## 概述

机器学习模块提供完整的量化因子挖掘和模型训练能力，支持从因子计算、标签生成到模型训练的全流程。模块采用插件化设计，支持多种因子库（Alpha101、Alpha158 等）和训练器（XGBoost、GRU 等）。

## 核心组件

### 组件层次结构

```text
TrainingEngine (训练引擎)
├── FeatureEngine (特征工程引擎)
│   └── DualModeFactor[] (双模因子)
│       ├── Alpha101 因子
│       ├── Alpha158 因子
│       ├── Alpha191 因子
│       ├── 技术因子
│       └── 自定义因子
├── LabelGenerator (标签生成器)
│   ├── FutureReturnLabel    # 未来收益标签
│   ├── DirectionLabel       # 方向标签
│   ├── RankLabel            # 排名标签
│   └── MultiLabel           # 多标签
├── BaseTrainer (训练器)
│   ├── XGBoostTrainer       # XGBoost
│   └── GRUTrainer           # GRU 神经网络
└── ModelEvaluator (模型评估器)
```

### `FeatureEngine` - 特征工程引擎

```python
class FeatureEngine:
    """
    特征工程引擎，支持流式和批量计算
    
    自动处理 symbol 和 timeframe 的 label encoding
    """
    
    def __init__(
        self, 
        factors: List[DualModeFactor],
        factor_ids: List[str] = None,
        symbol_encoder: Optional[OneHotEncoder] = None,
        timeframe_encoder: Optional[LabelEncoder] = None,
        enable_symbol_timeframe_encoding: bool = True
    ):
        ...
    
    def update(self, kline: KLine) -> np.ndarray:
        """[实盘模式] 更新并返回当前特征向量"""
        ...
    
    def compute(self, df: pd.DataFrame) -> pd.DataFrame:
        """[批量模式] 批量计算特征"""
        ...
    
    @property
    def feature_names(self) -> List[str]:
        """获取特征名称列表"""
        ...
```

### `LabelGenerator` - 标签生成器

```python
class LabelGenerator(ABC):
    """标签生成器基类"""
    
    @abstractmethod
    def generate(self, df: pd.DataFrame) -> pd.Series:
        """
        生成标签
        
        参数:
            df: 包含 OHLCV 数据的 DataFrame
            
        返回:
            标签 Series
        """
        ...
    
    @property
    def label_name(self) -> str:
        """标签列名"""
        ...
```

### `BaseTrainer` - 训练器基类

```python
class BaseTrainer(ABC):
    """模型训练器基类"""
    
    task_type: str = "classification"  # 或 "regression"
    
    @abstractmethod
    def fit(self, X: np.ndarray, y: np.ndarray, **kwargs):
        """训练模型"""
        ...
    
    @abstractmethod
    def predict(self, X: np.ndarray) -> np.ndarray:
        """预测"""
        ...
    
    @abstractmethod
    def save(self, path: str):
        """保存模型"""
        ...
    
    @abstractmethod
    def load(self, path: str):
        """加载模型"""
        ...
```

## 内置因子库

### Alpha101 因子

基于 WorldQuant Alpha101 论文的因子实现：

```python
from leek_core.ml.factors import Alpha101

# 创建 Alpha101 因子
alpha101 = Alpha101()

# 批量计算
df_with_factors = alpha101.compute(df)
```

### Alpha158 因子

Qlib Alpha158 因子集：

```python
from leek_core.ml.factors import Alpha158

alpha158 = Alpha158()
```

### Alpha191 因子

Alpha191 因子集：

```python
from leek_core.ml.factors import Alpha191

alpha191 = Alpha191()
```

### 技术因子

常用技术指标因子：

```python
from leek_core.ml.factors import TechnicalFactor

tech = TechnicalFactor(
    ma_periods=[5, 10, 20, 60],
    rsi_period=14,
    macd_params=(12, 26, 9),
)
```

### 动量因子

```python
from leek_core.ml.factors import MomentumFactor

momentum = MomentumFactor(
    periods=[1, 5, 10, 20],
    include_volume=True,
)
```

## 内置标签生成器

### 未来收益标签

```python
from leek_core.ml.label import FutureReturnLabel

# 未来5根K线的收益率
label_gen = FutureReturnLabel(
    periods=5,
    threshold=0.02,  # 2%阈值分类
)
```

### 方向标签

```python
from leek_core.ml.label import DirectionLabel

# 二分类：涨/跌
label_gen = DirectionLabel(
    periods=5,
    threshold=0.0,
)
```

### 排名标签

```python
from leek_core.ml.label import RankLabel

# 未来收益排名分组
label_gen = RankLabel(
    periods=5,
    n_groups=5,  # 分5组
)
```

### 多标签

```python
from leek_core.ml.label import MultiLabel

# 多任务学习标签
label_gen = MultiLabel([
    DirectionLabel(periods=5),
    FutureReturnLabel(periods=5),
])
```

## 内置训练器

### XGBoost 训练器

```python
from leek_core.ml.trainer import XGBoostTrainer

trainer = XGBoostTrainer(
    n_estimators=100,
    max_depth=6,
    learning_rate=0.1,
    objective="binary:logistic",  # 或 "reg:squarederror"
)
```

### GRU 训练器

```python
from leek_core.ml.trainer import GRUTrainer

trainer = GRUTrainer(
    input_size=None,  # 自动推断
    hidden_size=64,
    num_layers=2,
    dropout=0.2,
    sequence_length=20,
    batch_size=32,
    epochs=100,
    learning_rate=0.001,
)
```

## 训练流程

### 完整训练配置

```python
config = {
    "id": 1,
    "name": "BTC策略模型训练",
    
    # 数据配置
    "symbols": ["BTC", "ETH", "SOL"],
    "timeframes": ["1h"],
    "start_time": "2024-01-01",
    "end_time": "2024-06-01",
    
    # 数据源
    "datasource_class": "leek_core.data.ClickHouseSource",
    "datasource_config": {
        "host": "localhost",
        "database": "market_data",
    },
    "datasource_extra": {
        "quote_currency": "USDT",
        "ins_type": "SWAP",
        "market": "okx",
    },
    
    # 因子配置
    "factors": [
        {
            "id": 1,
            "name": "Alpha101",
            "class_name": "leek_core.ml.factors.Alpha101",
            "params": {}
        },
        {
            "id": 2,
            "name": "Technical",
            "class_name": "leek_core.ml.factors.TechnicalFactor",
            "params": {"ma_periods": [5, 10, 20]}
        },
    ],
    
    # 标签生成器
    "label_generator": {
        "id": 1,
        "name": "direction",
        "class_name": "leek_core.ml.label.DirectionLabel",
        "params": {"periods": 5}
    },
    
    # 训练器
    "trainer": {
        "id": 1,
        "name": "xgboost",
        "class_name": "leek_core.ml.trainer.XGBoostTrainer",
        "params": {
            "n_estimators": 100,
            "max_depth": 6,
        }
    },
    
    # 模型路径
    "save_model_path": "/path/to/models/",
    "load_model_path": None,  # 增量训练时指定
    
    # 训练参数
    "train_split_ratio": 0.8,
    "enable_symbol_timeframe_encoding": True,
}
```

### 启动训练

```python
from leek_core.ml import training

# 同步训练
result = training(config)

# 异步训练（带进度回调）
from multiprocessing import Queue

queue = Queue()
training(config, queue=queue)

# 监听进度
while True:
    msg = queue.get()
    print(f"Phase: {msg['phase']}, Status: {msg['status']}")
    if msg['phase'] == 'completed':
        break
```

### 训练进度回调

```python
# 回调消息格式
{
    'phase': 'initializing' | 'loading_data' | 'computing_features' | 
             'generating_labels' | 'training' | 'evaluating' | 'completed',
    'status': 'running' | 'success' | 'error',
    'progress': 0.0 ~ 1.0,  # 当前阶段进度
    'message': '...',        # 详细信息
    'metrics': {...},        # 评估指标（完成时）
}
```

## 模型评估

### ModelEvaluator

```python
from leek_core.ml import ModelEvaluator

evaluator = ModelEvaluator(task_type="classification")

# 评估模型
metrics = evaluator.evaluate(y_true, y_pred, y_prob)

# 分类任务指标
# - accuracy: 准确率
# - precision: 精确率
# - recall: 召回率
# - f1: F1分数
# - auc: AUC值
# - confusion_matrix: 混淆矩阵

# 回归任务指标
# - mse: 均方误差
# - rmse: 均方根误差
# - mae: 平均绝对误差
# - r2: R²分数
# - ic: 信息系数
# - rank_ic: 秩信息系数
```

## 在策略中使用模型

### ML 策略示例

```python
from leek_core.strategy import Strategy
from leek_core.ml import FeatureEngine
from leek_core.models import PositionSide, KLine
import joblib

class MLStrategy(Strategy):
    """机器学习策略"""
    
    display_name = "ML策略"
    
    def __init__(self, model_path: str, threshold: float = 0.6):
        super().__init__()
        self.threshold = threshold
        
        # 加载模型和特征引擎
        model_data = joblib.load(model_path)
        self.model = model_data['model']
        self.feature_engine = model_data['feature_engine']
    
    def on_data(self, data):
        if not isinstance(data, KLine):
            return
        
        # 计算特征
        features = self.feature_engine.update(data)
        
        if features is None or any(f is None for f in features):
            return
        
        # 预测
        X = features.reshape(1, -1)
        prob = self.model.predict_proba(X)[0]
        
        # 存储预测结果
        self.current_prob = prob
    
    def should_open(self) -> PositionSide | None:
        if not hasattr(self, 'current_prob'):
            return None
        
        prob_up = self.current_prob[1]  # 上涨概率
        prob_down = self.current_prob[0]  # 下跌概率
        
        if prob_up > self.threshold:
            return PositionSide.LONG
        elif prob_down > self.threshold:
            return PositionSide.SHORT
        
        return None
    
    def should_close(self, position_side: PositionSide) -> bool:
        if not hasattr(self, 'current_prob'):
            return False
        
        # 信号反转时平仓
        if position_side == PositionSide.LONG:
            return self.current_prob[0] > self.threshold
        else:
            return self.current_prob[1] > self.threshold
```

## 自定义因子

### 实现自定义因子

```python
from leek_core.ml.factors import DualModeFactor
from leek_core.models import KLine
import pandas as pd
import numpy as np

class CustomFactor(DualModeFactor):
    """自定义因子"""
    
    display_name = "自定义因子"
    _name = "custom"
    _required_buffer_size = 20
    
    def __init__(self, period: int = 10):
        super().__init__()
        self.period = period
        self._buffer = []
    
    def update(self, kline: KLine) -> float | None:
        """流式计算"""
        self._buffer.append(float(kline.close))
        if len(self._buffer) > self._required_buffer_size:
            self._buffer = self._buffer[-self._required_buffer_size:]
        
        if len(self._buffer) < self.period:
            return None
        
        # 计算因子值
        returns = np.diff(self._buffer[-self.period:]) / np.array(self._buffer[-self.period:-1])
        return float(np.std(returns))
    
    def compute(self, df: pd.DataFrame) -> pd.DataFrame:
        """批量计算"""
        returns = df['close'].pct_change()
        df[f'{self._name}_volatility'] = returns.rolling(self.period).std()
        return df
    
    def get_output_names(self) -> list[str]:
        return [f'{self._name}_volatility']
```

## 最佳实践

### 1. 特征工程

```python
# 特征标准化
from sklearn.preprocessing import StandardScaler

scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

# 特征选择
from sklearn.feature_selection import SelectKBest, f_classif

selector = SelectKBest(f_classif, k=50)
X_selected = selector.fit_transform(X, y)
```

### 2. 避免过拟合

```python
# 使用交叉验证
from sklearn.model_selection import TimeSeriesSplit

tscv = TimeSeriesSplit(n_splits=5)
for train_idx, val_idx in tscv.split(X):
    X_train, X_val = X[train_idx], X[val_idx]
    y_train, y_val = y[train_idx], y[val_idx]
    # 训练和验证
```

### 3. 模型持久化

```python
import joblib

# 保存完整的预测管道
pipeline = {
    'model': trainer.model,
    'feature_engine': feature_engine,
    'scaler': scaler,
    'feature_names': feature_engine.feature_names,
    'label_encoder': label_encoder,
}

joblib.dump(pipeline, 'model_pipeline.joblib')

# 加载
pipeline = joblib.load('model_pipeline.joblib')
```

## 相关模块

- [因子模块](06-factor.md) - DualModeFactor 详情
- [策略模块](01-strategy.md) - 策略开发
- [回测系统](30-backtest.md) - 模型回测验证
